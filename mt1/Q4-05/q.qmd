
```{python}
#| label: q4_05_huron_ljung_box
#| echo: false
#| output: asis
import numpy as np
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.stats.diagnostic import acorr_ljungbox
import os

dat = pd.read_csv("data/huron_level.csv", comment='#')
huron_level = dat[' Jan'].values
year = dat['Year'].values

def aic_blt_table(data, P, Q, blt_lag=5):
    """
    Create AIC and Ljung-Box test tables for ARMA(p,q) models.

    Parameters:
    -----------
    data : array-like
        Time series data
    P : int
        Maximum AR order
    Q : int
        Maximum MA order
    blt_lag : int
        Lag for Ljung-Box test

    Returns:
    --------
    dict with 'aic' and 'blt' DataFrames
    """
    aic_table = np.full((P+1, Q+1), np.nan)
    blt_table = np.full((P+1, Q+1), np.nan)

    for p in range(P+1):
        for q in range(Q+1):
            try:
                mod = ARIMA(data, order=(p, 0, q),trend='c').fit(method_kwargs={'warn_convergence': False})
                aic_table[p, q] = mod.aic

                # Ljung-Box test on residuals
                lb_test = acorr_ljungbox(mod.resid, lags=[blt_lag], return_df=False)
                blt_table[p, q] = lb_test.iloc[0]['lb_pvalue']  # p-value
            except:
                # If model fails to fit, leave as NaN
                pass

    # Create DataFrames with proper labels
    row_labels = [f'AR{p}' for p in range(P+1)]
    aic_cols = [f'AIC MA{q}' for q in range(Q+1)]
    blt_cols = [f'LBT MA{q}' for q in range(Q+1)]

    aic_df = pd.DataFrame(aic_table, index=row_labels, columns=aic_cols)
    blt_df = pd.DataFrame(blt_table, index=row_labels, columns=blt_cols)

    # Round for display
    aic_df = aic_df.round(2)
    blt_df = blt_df.map(lambda x: f'{x:.3g}' if pd.notna(x) else 'NaN')

    return {'aic': aic_df, 'blt': blt_df}

# Check if cached version exists, otherwise compute
cache_file = "data/aic_blt_table.pkl"
if os.path.exists(cache_file):
    ab_table = pd.read_pickle(cache_file)
else:
    ab_table = aic_blt_table(huron_level, P=4, Q=4)
    pd.to_pickle(ab_table, cache_file)

# Combine tables side by side
combined = pd.concat([ab_table['aic'], ab_table['blt']], axis=1)
print(combined.to_markdown())
```

The [Ljung-Box test (LBT)](https://wikipedia.org/wiki/Ljung-Box_test) provides an alternative approach to comparison of AIC values for selecting ARMA models. Whereas the standard sample autocorrelation function (ACF) residual plot tests each ACF component $\hat\rho_k$ under a null hypothesis of white noise, LBT tests $\sum_{k=1}^h \hat\rho_k^2$. Here, we present an AIC table and an LBT table (for $h=5$). This course have favored AIC, with visual inspection of ACF and checking whether residual patterns appear in the frequency domain. There may be reasons to prefer LBT. Which of the following are good reasons to use LBT?

(i). LBT provides a p-value which is more formal than the comparison of AIC values.\
(ii). Numerical issues involved in fitting an ARMA model may cause problems for comparing AIC values.\
(iii). The LBT gives insights into what model to investigate next if the null hypothesis is rejected.\
(iv). The LBT is useful in conjunction with AIC and ACF, since it provides an alternative perspective.

**A.** (i) only\
**B.** (i, ii, iv)\
**C.** (i,iii, iv)\
**D.** (ii, iii, iv)\
**E.** None of the above




